describe Akasha::Aggregate do
  let(:item) { Item.new(id) }
  let(:id) { 'item-1' }

  before(:all) do
    # Freeze time to make event comparison easier
    # (because they'll all have the same `created_at` time
    Timecop.freeze
  end

  after(:all) do
    Timecop.return
  end

  describe '#changeset' do
    subject { item.changeset }

    it 'describes only one aggregate' do
      expect(subject.aggregate_id).to eq(id)
    end

    context 'of unmodified aggregate' do
      it 'is empty' do
        expect(subject.events).to be_empty
      end
    end

    context 'of modified aggregate' do
      before do
        item.name = 'new name'
      end

      it 'is not empty' do
        expect(subject.events).to_not be_empty
      end

      it 'contains one event generated by Item' do
        expect(subject.events).to match_events [
          Akasha::Event.new(:name_changed, old_name: nil, new_name: 'new name')
        ]
      end
    end
  end

  describe '#apply_events' do
    let(:events) do
      [
        Akasha::RecordedEvent.new(:name_changed, id1, 0, updated_at, {}, old_name: nil, new_name: 'new name'),
        Akasha::RecordedEvent.new(:name_changed, id2, 1, updated_at, {}, old_name: 'new_name', new_name: 'newest name')
      ]
    end

    let(:id1) { 'id1' }
    let(:id2) { 'id2' }
    let(:id3) { 'id3' }
    let(:updated_at) { Time.now.utc }

    it 'should invoke event handlers for each event' do
      item.apply_events(events)
      expect(item.name).to eq 'newest name'
    end

    context 'given events without corresponding on_xx handlers' do
      let(:events) do
        [
          Akasha::RecordedEvent.new(:name_changed, id1, 0, updated_at, {}, old_name: nil, new_name: 'new name'),
          Akasha::RecordedEvent.new(:unexpected_happened, id2, 1, updated_at, {}),
          Akasha::RecordedEvent.new(:name_changed, id3, 2, updated_at, {}, old_name: 'new_name', new_name: 'newest name')
        ]
      end

      it 'raises no errors' do
        expect { item.apply_events(events) }.to_not raise_error
      end

      it 'applies all recognized events' do
        item.apply_events(events)
        expect(item.name).to eq 'newest name'
      end

      it 'sets revision to that of the last event' do
        item.apply_events(events)
        expect(item.revision).to eq 2
      end
    end
  end
end
