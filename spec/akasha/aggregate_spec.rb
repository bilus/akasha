describe Akasha::Aggregate do
  let(:item) { Item.new(id) }
  let(:id) { 'item-1' }

  before(:all) do
    # Freeze time to make event comparison easier
    # (because they'll all have the same `created_at` time
    Timecop.freeze
  end

  after(:all) do
    Timecop.return
  end

  describe '#changeset' do
    subject { item.changeset }

    it 'describes only one aggregate' do
      expect(subject.aggregate_id).to eq(id)
    end

    context 'of unmodified aggregate' do
      it 'is empty' do
        expect(subject.events).to be_empty
      end
    end

    context 'of modified aggregate' do
      before do
        item.name = 'new name'
      end

      it 'is not empty' do
        expect(subject.events).to_not be_empty
      end

      it 'contains one event generated by Item' do
        expect(subject.events).to match_events [
          Akasha::Event.new(:name_changed, old_name: nil, new_name: 'new name')
        ]
      end
    end
  end

  describe '#apply_events' do
    let(:events) do
      [
        Akasha::Event.new(:name_changed, old_name: nil, new_name: 'new name'),
        Akasha::Event.new(:name_changed, old_name: 'new_name', new_name: 'newest name')
      ]
    end

    it 'should invoke event handlers for each event' do
      item.apply_events(events)
      expect(item.name).to eq 'newest name'
    end

    context 'given events without corresponding on_xx handlers' do
      let(:events) do
        [
          Akasha::Event.new(:name_changed, old_name: nil, new_name: 'new name'),
          Akasha::Event.new(:unexpected_happened),
          Akasha::Event.new(:name_changed, old_name: 'new_name', new_name: 'newest name')
        ]
      end

      it 'raises no errors' do
        expect { item.apply_events(events) }.to_not raise_error
      end

      it 'applies all recognized events' do
        item.apply_events(events)
        expect(item.name).to eq 'newest name'
      end
    end
  end
end
